# Tools for css codes

from typing import List, Set, Dict

__all__ = [
    "commutation_test",
    "compute_kernel",
    "compute_logicals",
    "compute_pivots",
    "remove_duplicates_empties",
    "image_checker",
    "set_order",
    "order_set_list",
    "generate_check_dict",
    "generate_syndrome_dict",
    "pcm_to_sets",
    "max_elem",
    "min_elem",
]


def commutation_test(Sx: List[Set[int]], Sz: List[Set[int]]) -> bool:
    r"""
    Function for taking two lists of sets and determining if they satisfy the
    necessary constraint that every set from Sx has an even-cardinality
    intersection with every set from Sz. This is equivalent to the commutation
    constraint for the two classical codes comprising a CSS code.

    :param Sx:
    :param Sz:

    :return:
    """

    return all([(not len(sx & sz) % 2) for sx in Sx for sz in Sz])


def compute_kernel(set_list: List[Set[int]]) -> List[Set[int]]:
    r"""
    Function for computing the kernel of a check matrix represented by a list of sets.

    :param set_list:

    :return:
    """
    qlist = sorted(list(set.union(*set_list)))
    col_dict = {q: {q} for q in qlist}
    syndromes = generate_syndrome_dict(set_list)

    for qubit1 in qlist:
        if len(syndromes[qubit1]) > 0:
            mark = min(syndromes[qubit1])
            for qubit2 in qlist:
                if qubit2 != qubit1 and mark in syndromes[qubit2]:
                    syndromes[qubit2] ^= syndromes[qubit1]
                    col_dict[qubit2] ^= col_dict[qubit1]

    kern = []

    for qubit in qlist:
        if not len(syndromes[qubit]):
            kern.append(col_dict[qubit])

    return kern


def compute_logicals(set_list1: List[Set[int]], set_list2: List[Set[int]]):
    r"""
    Function for computing elements in the kernel of set_list1 that are
    not in the image of set_list2.

    :param set_list1:
    :param set_list2:

    :return: objects in the kernel of set_list1 that are not in the image of
            set_list2
    """

    kern1 = compute_kernel(set_list1)
    logicals = []
    for op1 in kern1:
        if not image_checker(set_list2 + logicals, op1):
            logicals.append(op1)
    return logicals


def compute_pivots(set_list: List[Set[int]]) -> List[int]:
    r"""
    Function for computing the pivot elements of a check matrix represented by a list of sets.

    :param set_list:

    :return:
    """

    qlist = sorted(list(set.union(*set_list)))
    col_dict = {q: {q} for q in qlist}
    syndromes = generate_syndrome_dict(set_list)
    pivots = []

    for qubit1 in qlist:
        if len(syndromes[qubit1]) > 0:
            mark = min(syndromes[qubit1])
            pivots.append(mark)
            for qubit2 in qlist:
                if qubit2 != qubit1 and mark in syndromes[qubit2]:
                    syndromes[qubit2] ^= syndromes[qubit1]
                    col_dict[qubit2] ^= col_dict[qubit1]

    return pivots


def remove_duplicates_empties(set_list: List[Set[int]]) -> List[Set[int]]:
    r"""
    Function that removes duplicate sets and empty sets from the input list of sets and returns the modified list.

    :param set_list:

    :return:
    """

    new_list = []
    for x in set_list:
        if x not in new_list:
            if len(x):
                new_list.append(x)

    return new_list


def image_checker(set_list: List[Set[int]], elem_set: Set[int]) -> bool:
    r"""
    Function that computes whether elem_set is in the group of bitstrings generated by set_list.

    :param set_list:
    :param elem_set:

    :return:
    """

    if elem_set in set_list:
        return True

    else:
        return not len(compute_pivots(set_list + [elem_set])) > len(
            compute_pivots(set_list)
        )


def set_order(set1: Set[int], set2: Set[int]) -> int:

    if not len(set1 - set2):
        return 0
    else:
        return int(min(set2 - set1) > min(set1 - set2))


def order_set_list(set_list: List[Set[int]]) -> List[Set[int]]:
    r"""
    Order a list of sets using a merge-sort algorithm with the set ordering determined by comparing
    the minimum unique element for two sets.

    :param set_list: A list of sets of integers.

    :return: A list of sets of integers ordered according to minimal unique element, without any
        duplicate sets or empty sets.
    """

    if len(set_list) < 2:
        return set_list
    else:
        first_half = order_set_list(set_list[: int(len(set_list) / 2)])
        second_half = order_set_list(set_list[int(len(set_list) / 2) :])
        both_halfs = [first_half, second_half]

        ordered_list = []

        while len(first_half) > 0 and len(second_half) > 0:
            ordered_list.append(
                both_halfs[set_order(first_half[0], second_half[0])].pop(0)
            )

        return set_list + first_half + second_half


def generate_check_dict(set_list: List[Set[int]]) -> Dict[int, Set[int]]:
    r"""
    Takes a list of sets and labels them according to the ordering defined in order_set_list.

    :param set_list: A list of sets of positive integers

    :return: A dictionary that maps integer labels to the sets of set_list
            corresponding to their place in the order.
    """

    check_dict: Dict[int, Set[int]] = {ii: set_list[ii] for ii in range(len(set_list))}

    return check_dict


def generate_syndrome_dict(set_list: List[Set[int]]) -> Dict[int, Set[int]]:
    r"""
    A function to generate a dictionary that maps qubit labels to a set of the labels of sets containing them.
    This is equivalent to the syndrome of a single qubit error acting on that qubit
    The labeling is assigned by the generate_check_dict function.

    :param set_list: List of sets of qubit labels
    :return: Dictionary mapping qubit labels to a set of the integer labels for the input sets
    """

    qubits = set.union(*set_list)

    qubit_dict: Dict[int, Set[int]] = {q: set() for q in list(qubits)}

    i2c = generate_check_dict(set_list)
    c2i = {tuple(sorted(list(v))): k for k, v in i2c.items()}

    for q in list(qubits):
        for chk in set_list:
            if q in chk:
                qubit_dict[q].add(c2i[tuple(sorted(list(chk)))])

    return qubit_dict


def pcm_to_sets(H: List[List[int]]) -> List[Set[int]]:
    r"""
    Takes in a parity check matrix and returns the supports as sets of qubit labels for each row, i.e., check operator

    :param H:

    :return:
    """

    gens = []

    for row in range(len(H)):
        row_set = set()
        for col in range(len(H[0])):
            if H[row][col]:
                row_set.add(col)
        gens.append(row_set)

    return gens


def max_elem(S: List[Set[int]]) -> int:
    r"""
    Takes in a list of sets of non-negative integers and outputs the maximum element over all sets

    :param S:

    :return:
    """

    full_set = set.union(*S)

    return max(full_set)


def min_elem(S: List[Set[int]]) -> int:
    r"""
    Takes in a list of sets of non-negative integers and outputs the minimum element over all sets

    :param S:

    :return:

    """
    full_set = set.union(*S)

    return min(full_set)
