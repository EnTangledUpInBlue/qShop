## Tools for css codes

from typing import List,Set,Dict



def commutation_test(Sx:List[Set[int]],Sz:List[Set[int]]) -> bool:
    r"""
    Function for taking two lists of sets and determining if they satisfy the necessary constraint that every set from Sx has an even-cardinality intersection with every set from Sz.
    This is equivalent to the commutation constraint for the two classical codes comprising a CSS code.
    """

    return all([(not len(sx&sz)%2) for sx in Sx for sz in Sz])

def compute_kernel(set_list:List[Set[int]]) -> List[Set[int]]:
    r"""
    Function for computing the kernel of a check matrix represented by a list of sets.


    """
    qlist= sorted(list(set.union(*set_list)))
    col_dict = {q:{q} for q in qlist}
    syndromes = generate_syndrome_dict(set_list)

    for qubit1 in qlist:
        if len(syndromes[qubit1])>0:
            mark = min(syndromes[qubit1])
            for qubit2 in qlist:
                if qubit2 != qubit1 and mark in syndromes[qubit2]:
                    syndromes[qubit2] ^= syndromes[qubit1]
                    col_dict[qubit2] ^= col_dict[qubit1]
    
    kern = []

    for qubit in qlist:
        if not len(syndromes[qubit]):
            kern.append(col_dict[qubit])

    return kern

def compute_logicals(set_list1:List[Set[int]],set_list2:List[Set[int]]):
    r"""
    Function for computing elements in the kernel of set_list1 that are
    not in the image of set_list2.

    :param set_list1:
    :param set_list2:
    :return: objects in the kernel of set_list1 that are not in the image of 
            set_list2
    """

    kern1 = compute_kernel(set_list1)
    logicals = []
    for op1 in kern1:
        if not image_checker(set_list2+logicals,op1):
            logicals.append(op1)
    return logicals

def compute_pivots(set_list:List[Set[int]]) -> List[int]:
    r"""
    Function for computing the pivot elements of a check matrix represented by a list of sets.


    """
    qlist= sorted(list(set.union(*set_list)))
    col_dict = {q:{q} for q in qlist}
    syndromes = generate_syndrome_dict(set_list)
    pivots = []

    for qubit1 in qlist:
        if len(syndromes[qubit1])>0:
            mark = min(syndromes[qubit1])
            pivots.append(mark)
            for qubit2 in qlist:
                if qubit2 != qubit1 and mark in syndromes[qubit2]:
                    syndromes[qubit2] ^= syndromes[qubit1]
                    col_dict[qubit2] ^= col_dict[qubit1]

    return pivots

def remove_duplicates_empties(set_list:List[Set[int]]) -> List[Set[int]]:
    r"""
    Function that removes duplicate sets and empty sets from the input list of sets and returns the modified list.
    """

    new_list = []
    for x in set_list:
        if x not in new_list:
            if len(x):
                new_list.append(x)
    
    return new_list

def image_checker(set_list:List[Set[int]],elem_set:Set[int]) -> bool:
    r"""
    Function that computes whether elem_set is in the group of bitstrings generated by set_list.
    """

    if elem_set in set_list:
        return True

    else:
        return not len(compute_pivots(set_list+[elem_set])) > len(compute_pivots(set_list))



def order_set_list(set_list:List[Set[int]]) -> List[Set[int]]:
    r"""
    Order a list of sets using a merge-sort algorithm with the set ordering determined by comparing 
    the minimum unique element for two sets.

    :param set_list: A list of sets of integers.
    :output: A list of sets of integers ordered according to minimal unique element, without any
        duplicate sets or empty sets.
    """

    set_list_update = remove_duplicates_empties(set_list)

    if len(set_list_update) < 2:
        return set_list_update
    
    elif len(set_list_update) == 2:
        ## There is (maybe now was) an issue if one set is a subset of the other

        if set_list_update[0] < set_list_update[1] or set_list_update[1]<set_list_update[0]:
            return order_set_list([set_list_update[0]^set_list_update[1],set_list_update[0]&set_list_update[1]])
        elif min(set_list_update[0]-set_list_update[1])<min(set_list_update[1]-set_list_update[0]):
            return set_list_update
        else:
            return [set_list_update[1],set_list_update[0]]
        
    else:
        num_sets = len(set_list_update)
        opening_set = order_set_list(set_list_update[:int(num_sets/2)])
        closing_set = order_set_list(set_list_update[int(num_sets/2):])

        full_set_list = []

        ## Also need to address the subset edge case here
        
        while(len(opening_set)>0 and len(closing_set) > 0):
            if opening_set[0] < closing_set[0] or closing_set[0]<opening_set[0]:
                opo = opening_set.pop(0)
                cpo = closing_set.pop(0)
                s1 = opo^cpo
                s2 = opo&cpo
                if min(s1-s2) < min(s2-s1):
                    full_set_list.append(s1)
                    full_set_list.append(s2)
                else:
                    full_set_list.append(s2)
                    full_set_list.append(s1)

            elif min(opening_set[0]-closing_set[0]) < min(closing_set[0] - opening_set[0]):
                full_set_list.append(opening_set.pop(0))            
            else:
                full_set_list.append(closing_set.pop(0))

        if len(opening_set)>0:
            full_set_list.extend(opening_set)
        else:
            full_set_list.extend(closing_set)
        
        return full_set_list
    
def generate_check_dict(set_list:List[Set[int]]) -> Dict[int,Set[int]]:
    r"""
    Takes a list of sets and labels them according to the ordering defined in order_set_list.

    :param set_list: A list of sets of positive integers
    :return: A dictionary that maps integer labels to the sets of set_list
            corresponding to their place in the order.
    """

    check_dict = dict()

    set_list_ordered = order_set_list(set_list)

    for i in range(len(set_list_ordered)):
        check_dict[i] = set_list_ordered[i]

    return check_dict

def generate_syndrome_dict(set_list:List[Set[int]]) -> Dict[int,Set[int]]:
    r"""
    A function to generate a dictionary that maps qubit labels to a set of the labels of sets containing them.
    This is equivalent to the syndrome of a single qubit error acting on that qubit
    The labeling is assigned by the generate_check_dict function.

    :param set_list: List of sets of qubit labels
    :return: Dictionary mapping qubit labels to a set of the integer labels for the input sets
    """

    qubits = set.union(*set_list)

    qubit_dict: Dict[int,Set[int]] = { q: set() for q in list(qubits)}

    i2c = generate_check_dict(set_list)
    c2i = {tuple(sorted(list(v))):k for k,v in i2c.items()}

    for q in list(qubits):
        for chk in set_list:
            if q in chk:
                qubit_dict[q].add(c2i[tuple(sorted(list(chk)))])

    return qubit_dict

def pcm_to_sets(H:List[List[int]]) -> List[Set[int]]:
    r"""
    Takes in a parity check matrix and returns the supports as sets of qubit labels for each row, i.e., check operator
    """

    gens = []

    for row in range(len(H)):
        row_set = set()
        for col in range(len(H[0])):
            if H[row][col]:
                row_set.add(col)
        gens.append(row_set)

    return gens

def max_elem(S:List[Set[int]]) -> int:
    r"""
    Takes in a list of sets of non-negative integers and outputs the maximum element over all sets
    """

    full_set = set.union(*S)

    return max(full_set)
    

def min_elem(S:List[Set[int]]) -> int:
    r"""
    Takes in a list of sets of non-negative integers and outputs the minimum element over all sets
    """
    full_set = set.union(*S)
    
    return min(full_set)